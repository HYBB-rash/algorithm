# 图论

## 最短路径算法

### `dijkstra`算法

1. 权值应随着题目的定义而变，抽象模型时去寻找应该作为权重的值
2. 先确定题目时有向图还是无向图，有向图和无向图对数据的处理不同
3. 有重边和无重边的处理也不同，最短路径一般取`min`即可

### 朴素`dijkstra`算法

下面给出了一个模板，是Y总的模板题的答案。这个是有向有重边图的写法

朴素算法一般用于稠密图，稠密图用矩阵实现。

朴素算法很适合有重边的题目。

如果题目说图没有重边，则不需要加那个`min`，直接赋值上去即可

无向图只需在给出的数据中加一个反向的边数据即可，即`g[y][x] = min(g[y][x])`

``` cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;

int g[N][N];    // 图数据
int dist[N];    // 距离矩阵
bool st[N];     // 标记点是否被经过过

int dijkstra(int n, int idxS, int idxE)
{
    memset(dist, 0x3f, sizeof dist);    // 初始化距离矩阵
    dist[idxS] = 0; // 起点到起点的距离是0

    for (int i = 0; i < n - 1; i ++) 
    {
        int t = -1; // 初始临时变量
        for (int j = 1; j <= n; j ++)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;  // 如果该点没有被记录过，且距离矩阵记录的是最小距离，就更新t临时变量

        for (int j = 1; j <= n; j ++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);  // 更新距离矩阵
        
        st[t] = true;   // 表示该点已经被途径过
    }

    if (dist[idxE] == 0x3f3f3f3f) return -1;    // 如果该点未被途径，则返回-1
    return dist[idxE];  // 否则返回实际的距离
}

int main() 
{
    memset(g, 0x3f, sizeof g);
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i ++)
    {
        int x, y, d;
        cin >> x >> y >> d;
        g[x][y] = min(g[x][y], d);  // 这是有向图，且有重边的写法。有重边且需要最小时取min即可
    }
    int ans = dijkstra(n, 1, n);
    cout << ans;
    return 0;
}
```

### 堆优化`dijkstra`算法

下面给出了一个模板，是Y总的模板题的答案。这个是有向图的写法

堆优化一般用于稀疏图，稀疏图用邻接表实现。

如果会出现重边，用堆优化不好做，尽量使用朴素算法。否则需要历遍链表去修改重边。

无向图和朴素算法一样，加一个`add(b, a, c)`即可。

``` cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

typedef pair<int, int> PII; // 定义一个堆里单位的数据结构，first是距离，second是节点编号

const int N = 1e6 + 10;

int n, m;
int h[N], w[N], e[N], ne[N], idx;   // 静态链表的定义
// h: 头指针,w: 权重,ne: 下一个指针, idx静态地址
int dist[N];    // 距离矩阵
bool st[N]; // 标记是否被经过过

void add(int a, int b, int c)   // 邻接表的添加节点
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;    // 初始临时变量
    priority_queue <PII, vector<PII>, greater<PII>> heap;   // 顶点堆
    heap.push({0, 1});  // 起点初始化

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
        
        // 节点编号，距离
        int ver = t.second, distance = t.first;

        // 查看该节点是否被途径过
        if (st[ver]) continue;
        // 标记，途径
        st[ver] = true;

        // 历遍链表
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];   // ver节点可以连接到的点的编号
            if (dist[j] > dist[ver] + w[i]) // 检测距离矩阵的距离是否可以更新
            {
                dist[j] = dist[ver] + w[i]; // 更新
                heap.push({dist[j], j});    // 往堆里放一会需要计算的点
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;   // 不能到达就返回-1
    return dist[n]; // 返回最后的值
}

int main () {

    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);   // 添加进表节点，有向图写法
    }
    
    cout << dijkstra() << endl;
    return 0;
}
```

### 题型

1. 单源最短路径
   1. `dijkstra`朴素算法
   2. `dijkstra`堆优化算法
2. 多源最短路径
3. 超级源点(将看似多源最短路径的算法改进成单元最短路径)

    > 例题：Acwing1148，算村庄到有商店的村庄的最短距离

    将看似多源最短路径的题目抽象成单源最短路径，达到降低复杂度的目的。不过这不是什么题目都能抽象的，应该是有条件的。

    首先，这种题的某些要你算的点一定是特殊的。一般这种点是**一类点**。像例题，图中的某些村庄(点)是商店(特殊)。然后题目会让你**算其他点到这些特殊点的最短距离**。如果直接当成多源最短路径，或者n遍单源最短路径算，大概率会`tle`。

    这里可以使用**超级源点**的思路。特殊设定一个点，称为**超级源点**，为每个特殊点建立一条到这个超级源点的**有向**边，且这条有向边的权重为**0**。

    然后，利用单源最短路径算法(`dijkstra`)，算这个超级源点到各个点的最短距离矩阵，得到的结果矩阵就是**所有点到图中特殊点的最短距离**。

    > 是不是一定是有向边不清楚，以后懂了再补上。

    原理要是想通了很简单，实际上就是利用了题目信息，减少了计算量。建立了一个通路之后，让一类特殊点变成了起点，减少了很多没必要的计算。
