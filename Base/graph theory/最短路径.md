---
title: 最短路径算法
date: 2021-03-18 15:57:32
tags:
---
# 图论

## 最短路径算法

是否存在最短路是存在限制的，即，图中不能出现负权环。出现了负权环，必定没有最短路。

> 这里的必定也没有这么必定，存在一种特殊情况可以在出现了负权环的时候也存在最短路。
> 即当负权环保证不出现在目的地路径上时，是能存在最短路的。
> 但一般默认，不能出现负权环

`dijkstra`算法默认全部边的权重都为正数。一旦有负权边，`dijkstra`算法不能使用。

`Bellman Ford`算法和`spfa`算法可以解决负权边。但依旧不能解决负权环。

一般来说`Bellman Ford`效率比`spfa`低，但它能解决最短路限制边数的问题。

`spfa`可以解决绝大多数最短路问题，连`dijkstra`算法能解决的都能高效解决，但是一旦出现网格图，稠密图，菊花图，`spfa`算法将会退化成`Bellman Ford`算法。因此`spfa`能解决绝大多数随即图问题。

### `dijkstra`算法

1. 权值应随着题目的定义而变，抽象模型时去寻找应该作为权重的值
2. 先确定题目时有向图还是无向图，有向图和无向图对数据的处理不同
3. 有重边和无重边的处理也不同，最短路径一般取`min`即可

### 朴素`dijkstra`算法

下面给出了一个模板，是Y总的模板题的答案。这个是有向有重边图的写法

朴素算法一般用于稠密图，稠密图用矩阵实现。

朴素算法很适合有重边的题目。

如果题目说图没有重边，则不需要加那个`min`，直接赋值上去即可

无向图只需在给出的数据中加一个反向的边数据即可，即`g[y][x] = min(g[y][x])`

``` cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;

int g[N][N];    // 图数据
int dist[N];    // 距离矩阵
bool st[N];     // 标记点是否被经过过

int dijkstra(int n, int idxS, int idxE)
{
    memset(dist, 0x3f, sizeof dist);    // 初始化距离矩阵
    dist[idxS] = 0; // 起点到起点的距离是0

    for (int i = 0; i < n - 1; i ++) 
    {
        int t = -1; // 初始临时变量
        for (int j = 1; j <= n; j ++)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;  // 如果该点没有被记录过，且距离矩阵记录的是最小距离，就更新t临时变量

        for (int j = 1; j <= n; j ++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);  // 更新距离矩阵
        
        st[t] = true;   // 表示该点已经被途径过
    }

    if (dist[idxE] == 0x3f3f3f3f) return -1;    // 如果该点未被途径，则返回-1
    return dist[idxE];  // 否则返回实际的距离
}

int main() 
{
    memset(g, 0x3f, sizeof g);
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i ++)
    {
        int x, y, d;
        cin >> x >> y >> d;
        g[x][y] = min(g[x][y], d);  // 这是有向图，且有重边的写法。有重边且需要最小时取min即可
    }
    int ans = dijkstra(n, 1, n);
    cout << ans;
    return 0;
}
```

### 堆优化`dijkstra`算法

下面给出了一个模板，是Y总的模板题的答案。这个是有向图的写法

堆优化一般用于稀疏图，稀疏图用邻接表实现。

如果会出现重边，用堆优化不好做，尽量使用朴素算法。否则需要历遍链表去修改重边。

无向图和朴素算法一样，加一个`add(b, a, c)`即可。

``` cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

typedef pair<int, int> PII; // 定义一个堆里单位的数据结构，first是距离，second是节点编号

const int N = 1e6 + 10;

int n, m;
int h[N], w[N], e[N], ne[N], idx;   // 静态链表的定义
// h: 头指针,w: 权重,ne: 下一个指针, idx静态地址
int dist[N];    // 距离矩阵
bool st[N]; // 标记是否被经过过

void add(int a, int b, int c)   // 邻接表的添加节点
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;    // 初始临时变量
    priority_queue <PII, vector<PII>, greater<PII>> heap;   // 顶点堆
    heap.push({0, 1});  // 起点初始化

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
        
        // 节点编号，距离
        int ver = t.second, distance = t.first;

        // 查看该节点是否被途径过
        if (st[ver]) continue;
        // 标记，途径
        st[ver] = true;

        // 历遍链表
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];   // ver节点可以连接到的点的编号
            if (dist[j] > dist[ver] + w[i]) // 检测距离矩阵的距离是否可以更新
            {
                dist[j] = dist[ver] + w[i]; // 更新
                heap.push({dist[j], j});    // 往堆里放一会需要计算的点
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;   // 不能到达就返回-1
    return dist[n]; // 返回最后的值
}

int main () {

    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);   // 添加进表节点，有向图写法
    }
    
    cout << dijkstra() << endl;
    return 0;
}
```

### `Bellman Ford`算法

> 可以解决负权的问题，模板题参考Acwing853

思路很简单，循环历遍所有边，对每个边都做一边松弛操作。算法可以证明当循环到n次时，一定能算出最短边。

这个算法是唯一可以在存在负权环图中使用的算法。**前提是这个负权环图模型限制了最短路的边数**，否则依然不可使用。

如果限制了变数，那就把循环n边改成循环k遍即可。

下面是`Bellman Ford`算法模板。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

int n, m, k;

const int N = 1e5 + 10;

int dist[N],backup[N];

struct Edge
{
    int a, b, w;
}edges[N];


int bellman_ford() {

    memset(dist, 0x3f, sizeof dist);    // 初始化dist数组
    dist[1] = 0;    // dist数组起点设定为0

    for (int i = 0; i < k; i ++) {  // 如果没有限制边数，这里就是点的个数，否则循环k次
        memcpy(backup, dist, sizeof dist);  // 这里要复制一下数组，否则直接用dist数组更行会出现串更的情况
        for (int j = 0; j < m; j ++) {  // 对每条边都循环一次
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > backup[a] + w) {  // 松弛操作
                dist[b] = backup[a] + w;
            }
        }
    }

    if (dist[n] > 0x3f3f3f3f /2) return -1;
    return dist[n];
}

int main() {

    cin >> n >> m >> k;

    for (int i = 0; i < m; i ++) {
        cin >> edges[i].a >> edges[i].b >> edges[i].w;
    }
    int ans = bellman_ford();
    if (ans == -1) cout << "impossible" << endl;
    else cout << ans << endl;
    return 0;

}
```

### 题型

1. 单源最短路径
   1. `dijkstra`朴素算法(模板)
   2. `dijkstra`堆优化算法(模板)
   3. `BF`算法(解决含负权的边，和最短路限制段数的情况)
2. 多源最短路径
3. 超级源点(将看似多源最短路径的算法改进成单元最短路径)

    > 例题：Acwing1148，算村庄到有商店的村庄的最短距离

    将看似多源最短路径的题目抽象成单源最短路径，达到降低复杂度的目的。不过这不是什么题目都能抽象的，应该是有条件的。

    首先，这种题的某些要你算的点一定是特殊的。一般这种点是**一类点**。像例题，图中的某些村庄(点)是商店(特殊)。然后题目会让你**算其他点到这些特殊点的最短距离**。如果直接当成多源最短路径，或者n遍单源最短路径算，大概率会`tle`。

    这里可以使用**超级源点**的思路。特殊设定一个点，称为**超级源点**，为每个特殊点建立一条到这个超级源点的**有向**边，且这条有向边的权重为**0**。

    然后，利用单源最短路径算法(`dijkstra`)，算这个超级源点到各个点的最短距离矩阵，得到的结果矩阵就是**所有点到图中特殊点的最短距离**。

    > 是不是一定是有向边不清楚，以后懂了再补上。

    原理要是想通了很简单，实际上就是利用了题目信息，减少了计算量。建立了一个通路之后，让一类特殊点变成了起点，减少了很多没必要的计算。
4. `dijkstra`算法+`dfs`回溯

   > 例题：Acwing1577题，pat的真题。pat好像很喜欢玩dijkstra+dfs的题目

   一般来说这种题目，它的最短路径不是只有唯一一条，而是有多条。并且权值不单一，可能是多种权值作为衡量的标准。

   准确点说的话就是：在满足某个权值最小之后，再满足第二个权值最小or最大，再满足第三个权值最小or最大那个样子。(这里的权值标尺不一定是线，可能是点)。因此解决这类问题的通解是将`dijkstra`算法算出的所有最短路径都保存下来。

   > 如果题目比较简单，可以直接根据题目做调整，不需要完全按照这个模型去做。这只是个通用的模型。dfs函数写起来还是很麻烦的。

   这里保存的办法还是很简单粗暴的。建立一个`pre`数组，数组里每个数据都是一个链表。而`pre`数组的**下标**代表的是图中点的编号。数组中的链表，存放的也是图中的编号，和数组下标的关系是**链表的编号代表的点 ---> 数组的下标代表的点**。

   举个例子：

   ```cpp
   a ---> c
   b ---> c
   那么，pre[c]的那个链表存放的就是a, b，从a，b可以到达c，所以c的pre里存着a和b
   ```

   看明白了例子，就知道大概是个什么思路了。`dfs`从终点开始，查看`pre`数组里存放的点，再对每个点做一遍`dfs`。递归的出口就是，`pre`数组的链表为空,说明到达起点，历遍了一整条最短路径，然后在递归的出口处理题目的要求即可。

   如果用`cpp`实现的话，会利用`vector`建立一个邻接表去实现。例题是一道很好的例题。不清楚的话尝试一下即可。

   > 下面就是例题答案。可以作为模板来使用

   ```cpp
   #include <iostream>
    #include <vector>
    #include <queue>
    #include <cstring>
    #include <string>
    #include <unordered_map>

    using namespace std;

    const int N = 1e3 + 10;

    typedef pair<int, int> PII;

    // 保存最短路径可以到这个点的上一个点的编号。用dfs回溯
    vector<vector<int>> pre(N); // pre数组，用来回溯路径，记录最短的路径的上一个点是什么

    int dist[N];
    bool st[N];
    int e[N], w[N], h[N], ne[N], idx;

    unordered_map<int, int> happy;
    unordered_map<string, int> city_idx;
    string citys[N];
    int c_idx = 0;

    void add (int a, int b, int c) {
        e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    }

    void dijkstra() {

        int start_idx = city_idx["ROM"];
        memset(dist, 0x3f, sizeof dist);
        dist[start_idx] = 0;
        priority_queue <PII, vector<PII>, greater<PII>> heap;
        heap.push({0, start_idx});
        
        while (heap.size()) {
            auto t = heap.top();
            int ver = t.second, distance = t.first;
            heap.pop();

            if (st[ver]) continue;
            st[ver] = true;

            for (int i = h[ver]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] > dist[ver] + w[i]) {
                    dist[j] = dist[ver] + w[i];
                    heap.push({dist[j], j});
                    pre[j].clear(); // 如果发现了有更短的路径，则需要清除之前的pre数组路径，之前的点数据都失效
                    pre[j].push_back(ver);  // 将新的点放入pre数组
                } else if (dist[j] == dist[ver] + w[i]) {
                    pre[j].push_back(ver);  // 将可以到达这个点的最短路径放进pre数组
                }
            }
        }
    }

    vector<int> ans, tmp;   // ans数组是保存最终答案，tmp数组是dfs的临时数组
    int max_happy = 0, min_steps = N, way_count = 0;    // 根据题目需求制定的变量

    void dfs(int idx, int weight, int steps) {
        if (pre[idx].empty()) { // 递归出口
            way_count ++;   // pre数组空了，说明到起点了，已经历遍了一整条路
            if (max_happy < weight) {   // 按照题目要求编写
                max_happy = weight;
                min_steps = steps;
                ans = tmp;
            } else if (max_happy == weight) {
                if (min_steps > steps) {
                    min_steps = steps;
                    ans = tmp;
                }
            }
            return ;
        }
        for (auto i : pre[idx]) {
            tmp.push_back(i);   // 路径记录
            dfs(i, weight + happy[i], steps + 1);
            tmp.pop_back(); // 回溯
        }
    }

    int main () {
        memset(h, -1, sizeof h);
        int n, m; string dest;
        cin >> n >> m >> dest;
        city_idx[dest] = c_idx ++;
        for (int i = 0; i < n - 1; i ++) {
            string city; int weight;
            cin >> city >> weight;
            citys[c_idx] = city;
            city_idx[city] = c_idx ++;
            happy[city_idx[city]] = weight;
        }

        for (int i = 0; i < m; i ++) {
            string start, end; int weight = 0;
            cin >> start >> end >> weight;
            int start_idx = city_idx[start], end_idx = city_idx[end];
            add(start_idx, end_idx, weight);
            add(end_idx, start_idx, weight);
        }

        dijkstra();
        dfs(city_idx[dest], 0, 0);
        cout << way_count << " " << dist[city_idx[dest]] << " " << max_happy << " " << max_happy / min_steps << endl;
        cout << dest;
        for (auto i : ans) cout << "->" << citys[i];
        return 0;
    }
   ```

5. 限制边数的最短路径问题(负权图)

   这里参考上面关于`Bellman Ford`算法的讲解，基本上是用这个算法解决这种题目。